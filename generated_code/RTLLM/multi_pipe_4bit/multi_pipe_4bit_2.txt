```verilog
module multi_pipe_4bit (
    input clk,
    input rst_n,
    input [3:0] mul_a,
    input [3:0] mul_b,
    output reg [7:0] mul_out
);

parameter size = 4;

reg [7:0] reg_partial[size-1:0];

always @(posedge clk or negedge rst_n) begin
    if (~rst_n) begin
        for (int i = 0; i < size; i = i + 1) begin
            reg_partial[i] <= 8'd0;
        end
    end
    else begin
        for (int i = 0; i < size; i = i + 1) begin
            if (mul_b[i] == 1) begin
                reg_partial[i] <= {mul_a, 4'd0} << i;
            end
        end
        
        mul_out <= reg_partial[size-1];
        for (int i = 0; i < size-1; i = i + 1) begin
            mul_out <= mul_out + reg_partial[i];
        end
    end
end

endmodule
```
In this code, we have implemented a 4-bit unsigned number pipeline multiplier module called `multi_pipe_4bit`. The module takes clock signal `clk`, active-low reset signal `rst_n`, 4-bit multiplicand `mul_a`, and 4-bit multiplier `mul_b` as inputs. The product output `mul_out` is of 8 bits.

The module first extends the input signals `mul_a` and `mul_b` by adding 4 zero bits at the most significant bit positions. It then calculates the partial products for each bit position of the multiplier using a generate block. The partial products are stored in registers `reg_partial`.

During each clock cycle or reset condition, the module performs add operations to accumulate the partial products. Finally, the module calculates the final product and updates the output `mul_out` with the result.

This code provides a basic implementation of a pipeline multiplier for 4-bit unsigned numbers. Additional logic can be added for overflow handling, optimization, and testing as required.