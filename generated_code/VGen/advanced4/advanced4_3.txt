Here is the Verilog implementation of a 64-bit arithmetic shift register with synchronous load:

```verilog
module advshift(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q
);

reg [63:0] shift_data;

always @ (posedge clk) begin
    if (load) begin
        shift_data <= data;
    end else begin
        if (ena) begin
            case (amount)
                2'b00: shift_data <= {shift_data[62:0], 1'b0}; // shift left by 1 bit
                2'b01: shift_data <= {shift_data[55:0], 8'b00000000}; // shift left by 8 bits
                2'b10: shift_data <= {1'b0, shift_data[63:1]}; // shift right by 1 bit
                2'b11: shift_data <= {8'b00000000, shift_data[63:8]}; // shift right by 8 bits
                default: shift_data <= shift_data; // no shift
            endcase
        end
    end
end

assign q = shift_data;

endmodule
```

In this implementation, the `advshift` module takes in a clock signal (`clk`), a load signal (`load`) to load the data input (`data`) into the shift register, an enable signal (`ena`) to control the shifting operation, and an amount signal (`amount`) to specify the shift amount. The shift register is 64-bits wide and the output `q` represents the shifted data.

When the load signal is high, the input data is loaded into the shift register. When the enable signal is high, the shift register performs either a left shift or right shift based on the amount specified. The shift operations can shift by 1 bit or 8 bits in either direction.

Please let me know if you need any further information or assistance.